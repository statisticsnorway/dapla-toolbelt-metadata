"""Variable Definitions

## Introduction  Variable Definitions are centralized definitions of concrete variables which are typically present in multiple datasets. Variable Definitions support standardization of data and metadata and facilitate sharing and joining of data by clarifying when variables have an identical definition.  ## Maintenance of Variable Definitions This API allows for creation, maintenance and access of Variable Definitions.  ### Ownership Creation and maintenance of variables may only be performed by Statistics Norway employees representing a specific Dapla team, who are defined as the owners of a given Variable Definition. The team an owner represents must be specified when making a request through the `active_group` query parameter. All maintenance is to be performed by the owners, with no intervention from administrators.  ### Status All Variable Definitions have an associated status. The possible values for status are `DRAFT`, `PUBLISHED_INTERNAL` and `PUBLISHED_EXTERNAL`.   #### Draft When a Variable Definition is created it is assigned the status `DRAFT`. Under this status the Variable Definition is:  - Only visible to Statistics Norway employees. - Mutable (it may be changed directly without need for versioning). - Not suitable to refer to from other systems.  This status may be changed to `PUBLISHED_INTERNAL` or `PUBLISHED_EXTERNAL` with a direct update.  #### Published Internal Under this status the Variable Definition is:  - Only visible to Statistics Norway employees. - Immutable (all changes are versioned). - Suitable to refer to in internal systems for statistics production. - Not suitable to refer to for external use (for example in Statistikkbanken).  This status may be changed to `PUBLISHED_EXTERNAL` by creating a Patch version.  #### Published External Under this status the Variable Definition is:  - Visible to the general public. - Immutable (all changes are versioned). - Suitable to refer to from any system.  This status may not be changed as it would break immutability. If a Variable Definition is no longer relevant then its period of validity should be ended by specifying a `valid_until` date in a Patch version.  ### Immutability Variable Definitions are immutable. This means that any changes must be performed in a strict versioning system. Consumers can avoid being exposed to breaking changes by specifying a `date_of_validity` when they request a Variable Definition.  #### Patches Patches are for changes which do not affect the fundamental meaning of the Variable Definition.  #### Validity Periods Validity Periods are versions with a period defined by a `valid_from` date and optionally a `valid_until` date. If the fundamental meaning of a Variable Definition is to be changed, it should be done by creating a new Validity Period.

The version of the OpenAPI document: 0.1
Contact: metadata@ssb.no
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import date
from datetime import datetime
from typing import Any
from typing import ClassVar

from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import StrictBool
from pydantic import StrictInt
from pydantic import StrictStr
from typing_extensions import Self

from ..models.klass_reference import KlassReference
from ..models.rendered_contact import RenderedContact


class RenderedVariableDefinition(BaseModel):
    """Render a Variable Definition in a specific language, for display to end users."""

    id: StrictStr
    patch_id: StrictInt
    name: StrictStr | None = None
    short_name: StrictStr
    definition: StrictStr | None = None
    classification_uri: StrictStr | None = None
    unit_types: list[KlassReference | None]
    subject_fields: list[KlassReference | None]
    contains_special_categories_of_personal_data: StrictBool
    measurement_type: KlassReference | None = None
    valid_from: date
    valid_until: date | None = None
    external_reference_uri: StrictStr | None = None
    comment: StrictStr | None = None
    related_variable_definition_uris: list[StrictStr] | None = None
    contact: RenderedContact | None = None
    last_updated_at: datetime
    __properties: ClassVar[list[str]] = [
        "id",
        "patch_id",
        "name",
        "short_name",
        "definition",
        "classification_uri",
        "unit_types",
        "subject_fields",
        "contains_special_categories_of_personal_data",
        "measurement_type",
        "valid_from",
        "valid_until",
        "external_reference_uri",
        "comment",
        "related_variable_definition_uris",
        "contact",
        "last_updated_at",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self | None:
        """Create an instance of RenderedVariableDefinition from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in unit_types (list)
        _items = []
        if self.unit_types:
            for _item_unit_types in self.unit_types:
                if _item_unit_types:
                    _items.append(_item_unit_types.to_dict())
            _dict["unit_types"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subject_fields (list)
        _items = []
        if self.subject_fields:
            for _item_subject_fields in self.subject_fields:
                if _item_subject_fields:
                    _items.append(_item_subject_fields.to_dict())
            _dict["subject_fields"] = _items
        # override the default output from pydantic by calling `to_dict()` of measurement_type
        if self.measurement_type:
            _dict["measurement_type"] = self.measurement_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contact
        if self.contact:
            _dict["contact"] = self.contact.to_dict()
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict["name"] = None

        # set to None if definition (nullable) is None
        # and model_fields_set contains the field
        if self.definition is None and "definition" in self.model_fields_set:
            _dict["definition"] = None

        # set to None if classification_uri (nullable) is None
        # and model_fields_set contains the field
        if (
            self.classification_uri is None
            and "classification_uri" in self.model_fields_set
        ):
            _dict["classification_uri"] = None

        # set to None if measurement_type (nullable) is None
        # and model_fields_set contains the field
        if (
            self.measurement_type is None
            and "measurement_type" in self.model_fields_set
        ):
            _dict["measurement_type"] = None

        # set to None if valid_until (nullable) is None
        # and model_fields_set contains the field
        if self.valid_until is None and "valid_until" in self.model_fields_set:
            _dict["valid_until"] = None

        # set to None if external_reference_uri (nullable) is None
        # and model_fields_set contains the field
        if (
            self.external_reference_uri is None
            and "external_reference_uri" in self.model_fields_set
        ):
            _dict["external_reference_uri"] = None

        # set to None if comment (nullable) is None
        # and model_fields_set contains the field
        if self.comment is None and "comment" in self.model_fields_set:
            _dict["comment"] = None

        # set to None if related_variable_definition_uris (nullable) is None
        # and model_fields_set contains the field
        if (
            self.related_variable_definition_uris is None
            and "related_variable_definition_uris" in self.model_fields_set
        ):
            _dict["related_variable_definition_uris"] = None

        # set to None if contact (nullable) is None
        # and model_fields_set contains the field
        if self.contact is None and "contact" in self.model_fields_set:
            _dict["contact"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict[str, Any] | None) -> Self | None:
        """Create an instance of RenderedVariableDefinition from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "patch_id": obj.get("patch_id"),
                "name": obj.get("name"),
                "short_name": obj.get("short_name"),
                "definition": obj.get("definition"),
                "classification_uri": obj.get("classification_uri"),
                "unit_types": [
                    KlassReference.from_dict(_item) for _item in obj["unit_types"]
                ]
                if obj.get("unit_types") is not None
                else None,
                "subject_fields": [
                    KlassReference.from_dict(_item) for _item in obj["subject_fields"]
                ]
                if obj.get("subject_fields") is not None
                else None,
                "contains_special_categories_of_personal_data": obj.get(
                    "contains_special_categories_of_personal_data"
                ),
                "measurement_type": KlassReference.from_dict(obj["measurement_type"])
                if obj.get("measurement_type") is not None
                else None,
                "valid_from": obj.get("valid_from"),
                "valid_until": obj.get("valid_until"),
                "external_reference_uri": obj.get("external_reference_uri"),
                "comment": obj.get("comment"),
                "related_variable_definition_uris": obj.get(
                    "related_variable_definition_uris"
                ),
                "contact": RenderedContact.from_dict(obj["contact"])
                if obj.get("contact") is not None
                else None,
                "last_updated_at": obj.get("last_updated_at"),
            }
        )
        return _obj
