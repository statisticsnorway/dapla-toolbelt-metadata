"""Internal Variable Definitions Administration API

## Introduction  Variable Definitions are centralized definitions of concrete variables which are typically present in multiple datasets. Variable Definitions support standardization of data and metadata and facilitate sharing and joining of data by clarifying when variables have an identical definition.  ## Maintenance of Variable Definitions This API allows for creation, maintenance and access of Variable Definitions.  ### Ownership Creation and maintenance of variables may only be performed by Statistics Norway employees representing a specific Dapla team, who are defined as the owners of a given Variable Definition. The team an owner represents must be specified when making a request through the `active_group` query parameter. All maintenance is to be performed by the owners, with no intervention from administrators.  ### Status All Variable Definitions have an associated status. The possible values for status are `DRAFT`, `PUBLISHED_INTERNAL` and `PUBLISHED_EXTERNAL`.  #### Draft When a Variable Definition is created it is assigned the status `DRAFT`. Under this status the Variable Definition is:  - Only visible to Statistics Norway employees. - Mutable (it may be changed directly without need for versioning). - Not suitable to refer to from other systems.  This status may be changed to `PUBLISHED_INTERNAL` or `PUBLISHED_EXTERNAL` with a direct update.  #### Published Internal Under this status the Variable Definition is:  - Only visible to Statistics Norway employees. - Immutable (all changes are versioned). - Suitable to refer to in internal systems for statistics production. - Not suitable to refer to for external use (for example in Statistikkbanken).  This status may be changed to `PUBLISHED_EXTERNAL` by creating a Patch version.  #### Published External Under this status the Variable Definition is:  - Visible to the general public. - Immutable (all changes are versioned). - Suitable to refer to from any system.  This status may not be changed as it would break immutability. If a Variable Definition is no longer relevant then its period of validity should be ended by specifying a `valid_until` date in a Patch version.  ### Immutability Variable Definitions are immutable. This means that any changes must be performed in a strict versioning system. Consumers can avoid being exposed to breaking changes by specifying a `date_of_validity` when they request a Variable Definition.  #### Patches Patches are for changes which do not affect the fundamental meaning of the Variable Definition.  #### Validity Periods Validity Periods are versions with a period defined by a `valid_from` date and optionally a `valid_until` date. If the fundamental meaning of a Variable Definition is to be changed, it should be done by creating a new Validity Period.

The version of the OpenAPI document: 0.1
Contact: metadata@ssb.no
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from datetime import date
from datetime import datetime
from typing import Any
from typing import ClassVar

from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import StrictBool
from pydantic import StrictInt
from pydantic import StrictStr
from typing_extensions import Self

from ..models.klass_reference import KlassReference
from ..models.owner import Owner
from ..models.rendered_contact import RenderedContact
from ..models.variable_status import VariableStatus


class RenderedView(BaseModel):
    """Render a Variable Definition in a specific language, for display to end users."""

    id: StrictStr = Field(description="Unique identifier for the variable definition.")
    patch_id: StrictInt = Field(
        description="Integer identifying a patch of a variable definition."
    )
    name: StrictStr | None = Field(
        default=None,
        description="Name of the variable. Must be unique for a given Unit Type and Owner combination.",
    )
    short_name: StrictStr = Field(
        description="Recommended short name. Must be unique within an organization."
    )
    definition: StrictStr | None = Field(
        default=None, description="Definition of the variable."
    )
    classification_uri: StrictStr | None = Field(
        default=None,
        description="Link to the classification which defines all permitted values for this variable.",
    )
    unit_types: list[KlassReference]
    subject_fields: list[KlassReference]
    contains_special_categories_of_personal_data: StrictBool = Field(
        description="True if variable instances contain particularly sensitive information. Applies even if the information or identifiers are pseudonymized. Information within the following categories are regarded as particularly sensitive: Ethnicity, Political alignment, Religion, Philosophical beliefs, Union membership, Genetics, Biometrics, Health, Sexual relations, Sexual orientation"
    )
    variable_status: VariableStatus
    measurement_type: KlassReference | None = None
    valid_from: date = Field(
        description="The variable definition is valid from this date inclusive"
    )
    valid_until: date | None = Field(
        default=None,
        description="The variable definition is valid until this date inclusive",
    )
    external_reference_uri: StrictStr | None = Field(
        default=None, description="A link (URI) to an external definition/documentation"
    )
    comment: StrictStr | None = Field(
        default=None,
        description="Optional comment to explain the definition or communicate potential changes.",
    )
    related_variable_definition_uris: list[StrictStr] | None = Field(
        default=None,
        description="Link(s) to related definitions of variables - a list of one or more definitions. For example for a variable after-tax income it could be relevant to link to definitions of income from work, property income etc.",
    )
    owner: Owner
    contact: RenderedContact | None = None
    created_at: datetime = Field(
        description="The timestamp at which this variable definition was first created."
    )
    created_by: StrictStr = Field(
        description="The user who created this variable definition."
    )
    last_updated_at: datetime = Field(
        description="The timestamp at which this variable definition was last modified."
    )
    last_updated_by: StrictStr = Field(
        description="The user who last modified this variable definition."
    )
    __properties: ClassVar[list[str]] = [
        "id",
        "patch_id",
        "name",
        "short_name",
        "definition",
        "classification_uri",
        "unit_types",
        "subject_fields",
        "contains_special_categories_of_personal_data",
        "variable_status",
        "measurement_type",
        "valid_from",
        "valid_until",
        "external_reference_uri",
        "comment",
        "related_variable_definition_uris",
        "owner",
        "contact",
        "created_at",
        "created_by",
        "last_updated_at",
        "last_updated_by",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self | None:
        """Create an instance of RenderedView from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in unit_types (list)
        _items = []
        if self.unit_types:
            for _item_unit_types in self.unit_types:
                if _item_unit_types:
                    _items.append(_item_unit_types.to_dict())
            _dict["unit_types"] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subject_fields (list)
        _items = []
        if self.subject_fields:
            for _item_subject_fields in self.subject_fields:
                if _item_subject_fields:
                    _items.append(_item_subject_fields.to_dict())
            _dict["subject_fields"] = _items
        # override the default output from pydantic by calling `to_dict()` of measurement_type
        if self.measurement_type:
            _dict["measurement_type"] = self.measurement_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of owner
        if self.owner:
            _dict["owner"] = self.owner.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contact
        if self.contact:
            _dict["contact"] = self.contact.to_dict()
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict["name"] = None

        # set to None if definition (nullable) is None
        # and model_fields_set contains the field
        if self.definition is None and "definition" in self.model_fields_set:
            _dict["definition"] = None

        # set to None if classification_uri (nullable) is None
        # and model_fields_set contains the field
        if (
            self.classification_uri is None
            and "classification_uri" in self.model_fields_set
        ):
            _dict["classification_uri"] = None

        # set to None if measurement_type (nullable) is None
        # and model_fields_set contains the field
        if (
            self.measurement_type is None
            and "measurement_type" in self.model_fields_set
        ):
            _dict["measurement_type"] = None

        # set to None if valid_until (nullable) is None
        # and model_fields_set contains the field
        if self.valid_until is None and "valid_until" in self.model_fields_set:
            _dict["valid_until"] = None

        # set to None if external_reference_uri (nullable) is None
        # and model_fields_set contains the field
        if (
            self.external_reference_uri is None
            and "external_reference_uri" in self.model_fields_set
        ):
            _dict["external_reference_uri"] = None

        # set to None if comment (nullable) is None
        # and model_fields_set contains the field
        if self.comment is None and "comment" in self.model_fields_set:
            _dict["comment"] = None

        # set to None if related_variable_definition_uris (nullable) is None
        # and model_fields_set contains the field
        if (
            self.related_variable_definition_uris is None
            and "related_variable_definition_uris" in self.model_fields_set
        ):
            _dict["related_variable_definition_uris"] = None

        # set to None if contact (nullable) is None
        # and model_fields_set contains the field
        if self.contact is None and "contact" in self.model_fields_set:
            _dict["contact"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict[str, Any] | None) -> Self | None:
        """Create an instance of RenderedView from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "patch_id": obj.get("patch_id"),
                "name": obj.get("name"),
                "short_name": obj.get("short_name"),
                "definition": obj.get("definition"),
                "classification_uri": obj.get("classification_uri"),
                "unit_types": [
                    KlassReference.from_dict(_item) for _item in obj["unit_types"]
                ]
                if obj.get("unit_types") is not None
                else None,
                "subject_fields": [
                    KlassReference.from_dict(_item) for _item in obj["subject_fields"]
                ]
                if obj.get("subject_fields") is not None
                else None,
                "contains_special_categories_of_personal_data": obj.get(
                    "contains_special_categories_of_personal_data"
                ),
                "variable_status": obj.get("variable_status"),
                "measurement_type": KlassReference.from_dict(obj["measurement_type"])
                if obj.get("measurement_type") is not None
                else None,
                "valid_from": obj.get("valid_from"),
                "valid_until": obj.get("valid_until"),
                "external_reference_uri": obj.get("external_reference_uri"),
                "comment": obj.get("comment"),
                "related_variable_definition_uris": obj.get(
                    "related_variable_definition_uris"
                ),
                "owner": Owner.from_dict(obj["owner"])
                if obj.get("owner") is not None
                else None,
                "contact": RenderedContact.from_dict(obj["contact"])
                if obj.get("contact") is not None
                else None,
                "created_at": obj.get("created_at"),
                "created_by": obj.get("created_by"),
                "last_updated_at": obj.get("last_updated_at"),
                "last_updated_by": obj.get("last_updated_by"),
            }
        )
        return _obj
